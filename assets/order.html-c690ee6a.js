import{_ as e,M as s,p as o,q as c,N as t,a1 as n}from"./framework-8cd5abc2.js";const i={},p=n(`<h1 id="运行流程" tabindex="-1"><a class="header-anchor" href="#运行流程" aria-hidden="true">#</a> 运行流程</h1><h2 id="仪表盘启动流程" tabindex="-1"><a class="header-anchor" href="#仪表盘启动流程" aria-hidden="true">#</a> 仪表盘启动流程</h2><p>这个流程中的各种 <code>管理器</code> , <code>服务</code> , 源代码均在 <code>KitX Dashboard/Services/</code> 下</p><ol><li>初始化事件总线 (<code>EventHandlers</code>)</li><li>处理启动参数 (即命令行参数)</li><li>单进程检查 (防止多个实例同时运行)</li><li>启动时检查 <ol><li>读取配置文件, 初始化配置信息 (存在则读取, 不存在则初始化默认配置)</li><li>初始化日志系统, 开始记录日志</li><li>初始化全局异常捕获</li><li>初始化相关环境 (存在则读取, 不存在则重新创建) <ol><li>Common.Algorithm</li></ol></li><li>初始化数据库 (存在则读取, 不存在则重新创建)</li><li>初始化任务管理器 (<code>TasksManager</code>)</li><li>初始化网络管理器 (<code>WebManager</code>)</li><li>初始化数据记录管理器 (<code>StatisticsManager</code>)</li><li>初始化有关事件 (<code>EventHandlers</code>)</li><li>初始化文件监控管理器 (<code>FileWatcherManager</code>)</li></ol></li><li>进入应用生命周期, 启动图形化界面</li></ol><h2 id="网络初始化过程" tabindex="-1"><a class="header-anchor" href="#网络初始化过程" aria-hidden="true">#</a> 网络初始化过程</h2><ul><li>在 <code>仪表盘启动流程</code> 的 4.7 步中, 实际执行的代码是:<div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code>  <span class="token preprocessor property">#<span class="token directive keyword">region</span> 初始化 </span><span class="token return-type class-name">WebManager</span>

  Program<span class="token punctuation">.</span>TasksManager<span class="token punctuation">.</span><span class="token function">SignalRun</span><span class="token punctuation">(</span><span class="token keyword">nameof</span><span class="token punctuation">(</span>SignalsNames<span class="token punctuation">.</span>MainWindowInitSignal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token punctuation">{</span>
      <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
      <span class="token punctuation">{</span>
          Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>Program<span class="token punctuation">.</span>Config<span class="token punctuation">.</span>Web<span class="token punctuation">.</span>DelayStartSeconds <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          Program<span class="token punctuation">.</span>WebManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">WebManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token preprocessor property">#<span class="token directive keyword">endregion</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>这个任务将在 <code>MainWindow.xaml.cs</code> 中 <code>InitWindow()</code> 函数执行完毕时 <code>Raise</code><br> 并且休眠 <code>Program.Config.Web.DelayStartSeconds</code> 秒数后再开始启动网络相关服务</li><li><code>WebManager.Start()</code> 方法将分别初始化 <code>DevicesManager</code> , <code>DevicesServer</code> , <code>PluginsManager</code> 和 <code>PluginsServer</code></li><li><code>DevicesServer</code> 在调用 <code>Start()</code> 方法后开始向局域网多播本机的设备信息 udp 包, 表现形式为 <code>DeviceInfoStruct</code> 的 json 序列化字符串 (该结构定义于 <code>KitX.Web.Rules</code> 中)<br> 同时也会监听来自局域网组播的 udp 包, 并将其解析为 <code>DeviceInfoStruct</code> 结构, 并通过 <code>DevicesManager.Update(DeviceInfoStruct)</code> 方法将其添加到界面中</li><li><code>PluginsServer</code> 在调用 <code>Start()</code> 方法后开始监听网络连接请求并同请求的插件建立 tcp 连接, 接收到以 <code>&quot;PluginStruct: &quot;</code> 打头的报文之后将剩余部分作为 json 字符串反序列化为 <code>PluginStruct</code> 结构, 并通过 <code>PluginsManager.Execute(string, IPEndPoint)</code> 方法将其添加到界面中</li></ul><h2 id="自组网流程" tabindex="-1"><a class="header-anchor" href="#自组网流程" aria-hidden="true">#</a> 自组网流程</h2><p>基于局域网中不断发送的 udp 设备报文, KitX Dashboard 可以很轻松地判断出局域网中运行着 KitX Dashboard 的设备</p><p>在 udp 设备报文中增加 tcp 服务器相关字段, 即可依据 udp 设备报文自动建立连接, 组成网络</p><p>具体流程: (以某个设备的视角观察)</p>`,10),l=n('<p>当然, 观察的过程不会在连接主控或是建立主控后结束</p><p>这个观察的过程会持续进行, 以免发生网络内多台设备同时建立主控的情况</p><p>如果观察到有其它的主控的 udp 设备报文中的 <code>DeviceServerBuildTime</code> 字段早于自己的主控服务建立时间, 则主动关闭服务器, 并重新开始观察流程</p><h2 id="插件启动流程" tabindex="-1"><a class="header-anchor" href="#插件启动流程" aria-hidden="true">#</a> 插件启动流程</h2><ol><li>启动仪表盘</li><li>用户选择启动插件A</li><li>仪表盘根据插件A的 PluginStruct.json 中的 RootStartupFileName 字段以及 LoaderStruct.json 中的 LoaderName 字段拼凑启动命令<br> 根据 Config.json 中 Loaders.InstallPath 得到加载器安装路径, LoaderName 拼凑可执行文件名称来启动 Loader<br> 传入参数格式为: <code>--load {file} --connect {address}:{port}</code><br> 其中, <ol><li><code>{file}</code> 为插件根启动文件的绝对路径</li><li><code>{address}</code> 为当前仪表盘与插件连接的地址 (目前为内网 IPv4 地址)</li><li><code>{port}</code> 为当前仪表盘通讯服务器的服务端口</li></ol></li><li>Loader 启动后与仪表盘建立 Socket 连接, 通过 --connect 参数后指定的地址与端口<br> 启动后 Loader 向仪表盘发送一个文本, 格式为: <code>PluginStruct: {ps}</code>, 其中 <code>{ps}</code> 为 json 序列化的 PluginStruct 对象</li></ol>',5);function d(r,u){const a=s("Mermaid");return o(),c("div",null,[p,t(a,{id:"mermaid-136",code:"eJxlkM9KAlEUxvc+xV2OC3dBmxDyX7gIhHwBq6GEKBnTjQYWxZiaWISZTspQNkM5Tn8wBofyZeacO71F93pdBG7u4p7vfL/vfHtKJrdP0pEAIeuS5774ukl7HWjZUDODJBQKkzJUH8CoQ6NNv6+pq9GeAxefqF1BTS+TiOQbZ2APsDnE2y+ovtHuOSns5og//oEnFWtDbKtB5h6Zm0VLyfxmJnsYk4vZHXltWwnDex8rBnZsaD17zpRqgxOmjgp0WinIZRKT/FmfAXx7KFz53m+l68/UJZTnWCwBFyRTxRUCNw0iWFuyUpSV1JFyTMC6w/GEh1pgEpmDPOPESyIGe+loRFYJjnTuJC5kt+GHjtql57jYNASUZ43/z5qQfJWV2AB3Sl/rQiq6gnuTIxfqBZL3Hpv/bEjUNahrofUIjoOTU2rWuT4hpoE/kyLXKQ=="}),l])}const v=e(i,[["render",d],["__file","order.html.vue"]]);export{v as default};
