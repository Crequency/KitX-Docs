import{_ as e,p as a,q as t,a1 as c}from"./framework-a7aa02af.js";const d={},o=c('<h1 id="执行流程" tabindex="-1"><a class="header-anchor" href="#执行流程" aria-hidden="true">#</a> 执行流程</h1><h2 id="通信方式" tabindex="-1"><a class="header-anchor" href="#通信方式" aria-hidden="true">#</a> 通信方式</h2><p>我们使用 TCP 进行通信，以加载器为客户端, 以仪表板为服务端</p><h2 id="插件启动阶段" tabindex="-1"><a class="header-anchor" href="#插件启动阶段" aria-hidden="true">#</a> 插件启动阶段</h2><ol><li>通过主动加载器或自加载器，插件启动</li><li>向仪表盘发送 <code>PluginStruct</code> 的 Json 序列化文本, 格式: <code>PluginStruct: &lt;PluginStruct&gt;</code> 其中, <code>&lt;PluginStruct&gt;</code> 是 Json 序列化后的 <code>PluginsStruct</code> 文本</li><li>仪表盘接收到 <code>PluginStruct</code> 之后, 向加载器发送插件的工作路径, 格式: <code>WorkPath: &lt;WorkPath&gt;</code> 其中, <code>&lt;WorkPath&gt;</code> 是一个路径, 插件应该在这个路径下存放配置文件以及临时数据等</li><li>自由通信开始</li></ol><h2 id="自由通信阶段" tabindex="-1"><a class="header-anchor" href="#自由通信阶段" aria-hidden="true">#</a> 自由通信阶段</h2><p>仪表盘与加载器之间现在可以双向通信, 通信内容必须是 <code>Command</code> 类的 Json 序列化文本</p><h2 id="离线" tabindex="-1"><a class="header-anchor" href="#离线" aria-hidden="true">#</a> 离线</h2><p>当 Loader 一方因任意原因断开 TCP Socket 连接, Dashboard 都会认为插件离线</p>',9),r=[o];function i(h,n){return a(),t("div",null,r)}const s=e(d,[["render",i],["__file","process.html.vue"]]);export{s as default};
