import{_ as e,p as t,q as a,a1 as c}from"./framework-a7aa02af.js";const l={},o=c('<h1 id="主动加载器" tabindex="-1"><a class="header-anchor" href="#主动加载器" aria-hidden="true">#</a> 主动加载器</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>这类加载器是单独的程序, 通过其他方式与插件进行交互</p><p>例如: C# 中我们使用 MEF 框架进行实现插件的交互设计, 加载器将是单独的 exe 程序, 而插件则是单独的文件</p><p>要实现主动加载器, 最好视语言决定, 如果语言生态中已经有较好的实现方案, 那么再好不过了</p><p>这对有虚拟机的语言、可以动态调用的语言来说实现较为简单, 例如: C#, Java, Python</p><h2 id="主动加载插件的启动" tabindex="-1"><a class="header-anchor" href="#主动加载插件的启动" aria-hidden="true">#</a> 主动加载插件的启动</h2><ol><li>仪表盘执行 Shell 命令: <code>&lt;主动加载器程序文件&gt; --load &lt;插件&gt; --connect &lt;IP地址&gt;:&lt;端口&gt;</code></li><li>主动加载器启动</li><li>加载器调用插件入口点，插件启动</li></ol><h2 id="主动加载器的启动" tabindex="-1"><a class="header-anchor" href="#主动加载器的启动" aria-hidden="true">#</a> 主动加载器的启动</h2><ol><li>根据 <code>--load</code> 参数获取插件跟启动文件</li><li>插件框架启动</li><li>向仪表盘发送 <code>PluginStruct</code> 的 Json 序列化文本, 格式: <code>PluginStruct: &lt;PluginStruct&gt;</code> 其中, <code>&lt;PluginStruct&gt;</code> 是 Json 序列化后的 <code>PluginsStruct</code> 文本</li><li>仪表盘接收到 <code>PluginStruct</code> 之后, 向加载器发送插件的工作路径, 格式: <code>WorkPath: &lt;WorkPath&gt;</code> 其中, <code>&lt;WorkPath&gt;</code> 是一个路径, 插件应该在这个路径下存放配置文件以及临时数据等</li><li>自由通信开始</li></ol>',10),d=[o];function i(r,n){return t(),a("div",null,d)}const s=e(l,[["render",i],["__file","active-loader.html.vue"]]);export{s as default};
