import{_ as s,M as l,p as r,q as n,R as e,t,N as d,V as o,a1 as i}from"./framework-a7aa02af.js";const c={},h=i(`<p>首先, 我们需要知道加载器在 KitX 中的作用.</p><p>由于我们不可能将多种语言的插件交互逻辑都写入主程序, 于是我们设想, 是否能够通过中间程序负责具体交互, 并统一主程序与中间程序的通讯协议 ?</p><p>于是我们设计了 KitX 的三层架构:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>KitX 仪表板 &lt;-&gt; 加载器 &lt;-&gt; 插件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>加载器的目的是提供一个标准化的插件接口，方便使用多种编程语言开发 KitX 插件。</p><h2 id="加载器的分类" tabindex="-1"><a class="header-anchor" href="#加载器的分类" aria-hidden="true">#</a> 加载器的分类</h2>`,6),_=e("code",null,"主动加载器",-1),u=e("code",null,"被动加载器",-1),p=e("h2",{id:"加载器的执行流程-包括通信规则",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#加载器的执行流程-包括通信规则","aria-hidden":"true"},"#"),t(" 加载器的执行流程 (包括通信规则)")],-1),m=e("h2",{id:"加载器标准",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#加载器标准","aria-hidden":"true"},"#"),t(" 加载器标准")],-1),f=e("p",null,"以下是正在开发，或者已经完成的加载器的标准文档",-1);function x(v,b){const a=l("RouterLink");return r(),n("div",null,[h,e("p",null,[t("加载器主要分为 "),d(a,{to:"/rules/loader/active-loader.html"},{default:o(()=>[_]),_:1}),t(" 和 "),d(a,{to:"/rules/loader/self-loader.html"},{default:o(()=>[u]),_:1})]),p,e("p",null,[d(a,{to:"/rules/loader/process.html"},{default:o(()=>[t("点此查看")]),_:1})]),m,f])}const N=s(c,[["render",x],["__file","loader.html.vue"]]);export{N as default};
