import{_ as a,p as n,q as s,a1 as e}from"./framework-a7aa02af.js";const t={},p=e(`<p>首先, 我们需要知道加载器在 KitX Project 中的作用.</p><p>由于我们不可能将多种语言的插件交互逻辑都写入主程序, 于是我们设想, 是否能够通过中间程序负责具体交互, 并统一主程序与中间程序的通讯协议 ?</p><p>于是我们设计了 KitX Project 的三层设计:</p><p>KitX Dashboard &lt;-&gt; Loader &lt;-&gt; Plugin</p><p>加载器 (Loader) 在 KitX 支持多语言编写插件方面功不可没</p><h2 id="加载器的分类" tabindex="-1"><a class="header-anchor" href="#加载器的分类" aria-hidden="true">#</a> 加载器的分类</h2><p>加载器目前有两类:</p><ol><li><code>主动加载器</code></li><li><code>被动加载器</code> (自加载)</li></ol><h3 id="主动加载器" tabindex="-1"><a class="header-anchor" href="#主动加载器" aria-hidden="true">#</a> 主动加载器</h3><p>这类加载器是单独的程序, 通过其他方式与插件进行交互</p><p>例如: C# 中我们使用 MEF 框架进行实现插件的交互设计, 加载器将是单独的 exe 程序, 而插件则是单独的 dll 文件</p><p>要实现主动加载器, 最好视语言决定, 如果语言生态中已经有较好的实现方案, 那么再好不过了</p><p>这对有虚拟机的语言来说实现较为简单, 例如: C#, Java</p><p>但对于编译到机器码的语言来说就不是那么容易</p><p>例如我们为 C++ 开发主动加载器, 也许可以采取共享内存的方式通信</p><p>当然, 更好的方式是使用被动加载器</p><h3 id="被动加载器" tabindex="-1"><a class="header-anchor" href="#被动加载器" aria-hidden="true">#</a> 被动加载器</h3><p>被动加载器的加载方式也称为自加载</p><p>也就是编写一个对应语言的库, 在库中封装与 KitX Dashboard 通信的部分</p><p>以下是实现后的使用方式:</p><p>形如:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Loader</span> loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Loader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token namespace">loader<span class="token punctuation">.</span></span>Connect</span><span class="token punctuation">(</span>ipaddress<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name"><span class="token namespace">loader<span class="token punctuation">.</span></span>Register</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="加载器与仪表盘的通信规则" tabindex="-1"><a class="header-anchor" href="#加载器与仪表盘的通信规则" aria-hidden="true">#</a> 加载器与仪表盘的通信规则</h2><p>用户启动插件:</p><p>仪表盘执行 Shell: <code>loader --load &lt;path&gt; --connect &lt;ip&gt;:&lt;port&gt;</code> |</p><ul><li>loader 启动</li></ul><p>Loader 启动:</p><p>根据 <code>--load</code> 参数获取插件跟启动文件 |</p><ul><li>插件框架启动 | <ul><li>向仪表盘发送 <code>PluginStruct</code> 的 Json 序列化文本, 格式: <code>PluginStruct: &lt;PluginStruct&gt;</code> 其中, <code>&lt;PluginStruct&gt;</code> 是 Json 序列化后的 <code>PluginsStruct</code> 文本 | <ul><li>仪表盘接收到 <code>PluginStruct</code> 之后, 向加载器发送插件的工作路径, 格式: <code>WorkPath: &lt;WorkPath&gt;</code> 其中, <code>&lt;WorkPath&gt;</code> 是一个路径, 插件应该在这个路径下存放配置文件以及临时数据等 | <ul><li>自由通信开始</li></ul></li></ul></li></ul></li></ul><p>自由通信阶段:</p><p>仪表盘与加载器之间现在可以双向通信, 通信内容必须是 <code>Command</code> 类的 Json 序列化文本</p>`,31),o=[p];function c(l,d){return n(),s("div",null,o)}const r=a(t,[["render",c],["__file","loader.html.vue"]]);export{r as default};
